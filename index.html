<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pongo</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
    <script>
        // Initialisation de la scène, de la caméra, et du rendu
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Variables pour les interactions
        const lineLength = 5; // Longueur de la ligne de cubes pour chaque joueur
        const targetHeight = 0.6; // Hauteur cible lorsque le cube est sélectionné
        const liftSpeed = 0.1; // Vitesse de montée
        const moveSpeed = 0.3; // Vitesse de déplacement des lignes
        const initialBallSpeed = 0.2; // Vitesse initiale de la balle
        const ballSizeScale = 2; // Facteur d'échelle pour la taille de la balle (0.4 = 40% de la taille d'origine)
        const speedIncreaseFactor = 1.05; // Facteur d'augmentation de la vitesse à chaque touche

        // Nouvelles variables pour la plateforme rectangulaire
        const platformWidth = 50;  // Longueur de la plateforme
        const platformLength = 30; // Largeur de la plateforme
        const cubeSize = 1;
        const cubes = [];

        const createRoundedBox = (width, height, depth, radius, smoothness) => {
            const shape = new THREE.Shape();
            const eps = 0.00001;
            const radius0 = radius - eps;
            shape.absarc(eps, eps, eps, -Math.PI / 2, -Math.PI, true);
            shape.absarc(eps, height - radius * 2, eps, Math.PI, Math.PI / 2, true);
            shape.absarc(width - radius * 2, height - radius * 2, eps, Math.PI / 2, 0, true);
            shape.absarc(width - radius * 2, eps, eps, 0, -Math.PI / 2, true);
            const geometry = new THREE.ExtrudeBufferGeometry(shape, {
                depth: depth - radius0 * 2,
                bevelEnabled: true,
                bevelSegments: smoothness * 2,
                steps: 1,
                bevelSize: radius,
                bevelThickness: radius0,
                curveSegments: smoothness
            });
            geometry.center();
            return geometry;
        };

        // for (let i = 0; i < platformWidth; i++) {
        for (let i = 0; i < platformWidth; i += platformWidth - 1) {
        
            for (let j = 0; j < platformLength; j++) {
                const geometry = createRoundedBox(cubeSize, cubeSize, cubeSize, 0.18, 4);
                const material = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
                const cube = new THREE.Mesh(geometry, material);
                cube.position.set(i - platformWidth / 2 + 0.5, 0, j - platformLength / 2 + 0.5);
                cube.userData.gridPosition = { x: i, z: j };
                cubes.push(cube);
                scene.add(cube);
            }
        }
        const   middle = createRoundedBox(platformWidth - 2, cubeSize, platformLength, 0.18, 4);
        const   material = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
        const   cube = new THREE.Mesh(middle, material);
        cube.position.set(0, 0, 0);
        cube.userData.gridPosition = { x: 0, z: 0 };
        cubes.push(cube);
        scene.add(cube);

        // Add lighting to see the rounded edges better
        const ambientLight = new THREE.AmbientLight(0x606060);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        // Ajuster la position de la caméra pour la nouvelle plateforme
        camera.position.y = Math.max(platformWidth, platformLength) * 0.8;
        camera.position.z = Math.max(platformWidth, platformLength) * 1.2;
        camera.lookAt(0, 0, 0);

        // Variables pour suivre la position actuelle des curseurs
        if (lineLength == platformLength)
            centerZ = 0;
        else
            centerZ = Math.floor((platformLength - lineLength) / 2);
        let player1Positions = Array(lineLength).fill().map((_, index) => ({ x: 0, z: centerZ + index }));
        let player2Positions = Array(lineLength).fill().map((_, index) => ({ x: platformWidth - 1, z: centerZ + index }));


        // Create ball
        const ballGeometry = new THREE.SphereGeometry(0.2 * ballSizeScale, 32, 32);
        // const ballMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
		const ballMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xff0000,
            specular: 0x888888,
            shininess: 30
        });
        const ball = new THREE.Mesh(ballGeometry, ballMaterial);
        ball.position.set(0, 1, 0);
		ball.castShadow = true;
        ball.receiveShadow = true;
        scene.add(ball);

        // Ball movement
        let ballSpeed = initialBallSpeed;
        let ballVelocity = new THREE.Vector3(ballSpeed, 0, ballSpeed);

        // Object to track pressed keys
        const pressedKeys = {};

        // Fonction pour mettre à jour la sélection des cubes
        function updateCubeSelection() {
            cubes.forEach(cube => {
                cube.material.color.setHex(0xffffff);
                cube.userData.targetY = 0;
            });

            const updatePlayerCubes = (positions, color) => {
                positions.forEach((pos) => {
                    const cube = cubes.find(cube =>
                        cube.userData.gridPosition.x === Math.floor(pos.x) &&
                        cube.userData.gridPosition.z === Math.floor(pos.z)
                    );
                    if (cube) {
                        cube.material.color.setHex(color);
                        cube.userData.targetY = targetHeight;
                    }
                });
            };

            updatePlayerCubes(player1Positions, 0xffffff);
            updatePlayerCubes(player2Positions, 0xffffff);
        }

        // Fonction pour mettre à jour les positions des joueurs
        function updatePlayerPositions() {
            const movePlayer = (positions, direction) => {
                const newPositions = positions.map(pos => ({
                    x: pos.x,
                    z: pos.z + direction * moveSpeed
                }));

                // Check if any cube in the line would go out of bounds
                if (newPositions.every(pos => pos.z >= 0 && pos.z < platformLength)) {
                    return newPositions;
                }
                return positions;
            };

            // Player 1 movement
            if (pressedKeys['w'] || pressedKeys['a']) {
                player1Positions = movePlayer(player1Positions, -1);
            }
            if (pressedKeys['s'] || pressedKeys['d']) {
                player1Positions = movePlayer(player1Positions, 1);
            }

            // Player 2 movement
            if (pressedKeys['ArrowUp'] || pressedKeys['ArrowRight']) {
                player2Positions = movePlayer(player2Positions, -1);
            }
            if (pressedKeys['ArrowDown'] || pressedKeys['ArrowLeft']) {
                player2Positions = movePlayer(player2Positions, 1);
            }
        }

        function updateBallPosition() {
            const potentialPosition = ball.position.clone().add(ballVelocity);

            // Check for collisions with raised cubes
            let collision = false;
            cubes.forEach(cube => {
                if (cube.position.y > 0.1) {
                    const dx = Math.abs(potentialPosition.x - cube.position.x);
                    const dz = Math.abs(potentialPosition.z - cube.position.z);
                    if (dx < 0.6 && dz < 0.6) {
                        collision = true;
                        if (dx > dz) {
                            ballVelocity.x *= -1;
                        } else {
                            ballVelocity.z *= -1;
                        }
                        // Increase ball speed, but cap it at maxBallSpeed
                        ballSpeed = ballSpeed * speedIncreaseFactor;
                        ballVelocity.normalize().multiplyScalar(ballSpeed);
                    }
                }
            });

            // Only update the ball position if no collision occurred
            if (!collision) {
                ball.position.copy(potentialPosition);
            }

            // Check for collisions with grid boundaries
            if (ball.position.x < -platformWidth / 2 + 0.5 || ball.position.x > platformWidth / 2 - 0.5) {
                ballVelocity.x *= -1;
                ball.position.x = Math.max(Math.min(ball.position.x, platformWidth / 2 - 0.5), -platformWidth / 2 + 0.5);
            }
            if (ball.position.z < -platformLength / 2 + 0.5 || ball.position.z > platformLength / 2 - 0.5) {
                ballVelocity.z *= -1;
                ball.position.z = Math.max(Math.min(ball.position.z, platformLength / 2 - 0.5), -platformLength / 2 + 0.5);
            }

            // Check if ball is behind player lines
            if (ball.position.x < -platformWidth / 2 + 1 || ball.position.x > platformWidth / 2 - 1) {
                resetBall();
            }
        }

        function resetBall() {
            ball.position.set(0, 1, 0);
            ballSpeed = initialBallSpeed;
            ballVelocity = new THREE.Vector3(ballSpeed * (Math.random() > 0.5 ? 1 : -1), 0, ballSpeed * (Math.random() > 0.5 ? 1 : -1));
        }

        // Fonction d'animation
        function animate() {
            requestAnimationFrame(animate);

            updatePlayerPositions();
            updateCubeSelection();
            updateBallPosition();

            // Animation de montée et descente fluide
            cubes.forEach(cube => {
                if (cube.userData.targetY !== undefined) {
                    cube.position.y += (cube.userData.targetY - cube.position.y) * liftSpeed;
                }
            });

            renderer.render(scene, camera);
        }

        // Gestion des événements du clavier
        function onKeyDown(event) {
            pressedKeys[event.key] = true;
        }

        function onKeyUp(event) {
            pressedKeys[event.key] = false;
        }

        // Gestion du zoom avec la molette de la souris
        function onMouseWheel(event) {
            const zoomSpeed = 0.1;
            const zoomFactor = event.deltaY > 0 ? 1 + zoomSpeed : 1 - zoomSpeed;
            
            camera.position.y *= zoomFactor;
            camera.position.z *= zoomFactor;
            
            camera.lookAt(0, 0, 0);
        }

        window.addEventListener('keydown', onKeyDown, false);
        window.addEventListener('keyup', onKeyUp, false);
        window.addEventListener('wheel', onMouseWheel, false);

        // Démarrer l'animation
        animate();
    </script>
</body>

</html>